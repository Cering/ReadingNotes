# 《数据结构、算法与应用》

## 总结&思考

## 摘录

### 第1章 C++回顾

- 函数的签名由**形参类型**和**形参个数**确定，注意签名与函数的返回值类型无关
- new操作符分配内存失败的情况下，会抛出一个**bad_alloc**类型的异常
- 对用户隐藏类的实现细节的一个重大益处是，用新的、更高效的类对象描述取代以前的描述之后，应用代码 **不需要任何改动**
- 为了格式统一，友元声明语句应该总跟在**类标题语句之后**
- 递归函数分为基础部分和递归部分，**递归部分的每一次调用都会更加接近基础部分**
- 测试的目的不是要证明程序是否正确，而是要**暴露程序的错误**，设计测试数据时也应该以此为出发点

### 第2章 程序性能分析

- 程序所需要的空间 = c(固定部分与n无关) + S(可变部分与n有关)
- 时间复杂度估算：找出关键操作的执行时间，确定程序的总步数

### 第3章 渐近记法

- 渐近分析法主要是确定复杂函数中的**最大项**，但不包括最大项的系数
- 渐近记法复杂度排序：**O(1) < O(logn) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!)**
- 复杂度分析举例：确定每一条语句的渐近复杂度，取**最大值**作为整体的复杂度
- 在对两种算法的实际复杂度进行取舍时，必须搞清楚实例特征**n是否真的足够大**，足以拉开两种复杂度的差距

### 第4章 性能测量

- 无

### 第5章 线性表——数组描述

- 数组存储满后需要加大长度时，常用的做法是**数组倍增**(容量*2)，可改善连续插入时的时间复杂度 
- 数组描述的缺点是**空间利用率低**，可以尝试在一个数组中实现多重表存储

### 第6章 线性表——链式描述

- 链表使用**头节点**可以使程序更简洁、运行速度更快
- 稳定排序：保持同值元素之间的**相对次序**
- 基数排序：把数值按照某种基数分解为数字后进行排序，可以在**O(n)**时间内，对**0 ~ n^c-1**之间的n个整数进行排序
- 利用双向链表可以解决**凸包问题**，即寻找包含平面点集S的最小凸多边形

### 第7章 数组和矩阵

- 用一维数组可以表示对角矩阵，其中**element[i-1] = D(i,i)**
- 三角矩阵可以用大小为**n * (n+1) / 2**的一维矩阵来存储

### 第8章 栈

- 使用链表描述栈时，应该选择链表的**左端**作为栈顶，能有更好的时间复杂度
- 基于**递归**的算法实现，都可以转换为基于**栈**的循环实现，比如汉诺塔

### 第9章 队列

- 循环队列元素个数最多是**length-1**，全填满的话无法区分出队列是空还是满
- **广度优先搜索**适合用队列实现，**尝试优先搜索**适合用栈实现

### 第10章 跳表和散列

- 跳表是在链表中增加了额外的**向前指针**，i级链表每2^i个数对取一个，其查找、插入、删除的平均复杂度均为O(logn)
- 散列表的每个位置叫做**桶**，桶要能够容纳多个数对，**均匀散列函数**会使每个桶里的关键字数量大致相等
- 解决桶溢出的方法有**线性探查**和**链式散列**
- LFW压缩算法：不断搜索未编码部分，在字典中寻找与之匹配的最长字符串，输出其代码进行压缩